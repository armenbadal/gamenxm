
# Խաղ N×M

Իմ նպատակն է արդեն դասական դարձած _Խաղ 15_֊ի (Game 15, Puzzle 15) ընդհանրացված տարբերակի օրինակով ներկայացնել Qt գրադարանի հիմնական հասկացությունները։

## Խաղի նկարագրությունը

Խաղ 15֊ն իրենից ներկայացնում է մի քառակուսի շրջանակ (կամ արկղիկ), որի մեջ `4×4` կարգով դասավորված են 15 խաղաքարեր և մեկ դիրք էլ ազատ է։

```
+----+----+----+----+
|  1 |  2 |  3 |  4 |
+----+----+----+----+
|  5 |  6 |  7 |  8 |
+----+----+----+----+
|  9 | 10 | 11 | 12 |
+----+----+----+----+
| 13 | 14 | 15 |    |
+----+----+----+----+ 
```

Խաղի սկզբում խաղաքարերը խառնված են և խաղացողի նպատակն է, ազատ դիրքն օգտագործելով ու խաղաքարերը տեղաշարժելով, թվերը դասավորել աճման կարգով։ Բնականաբար, լավագույնն է համարվում քայլերի նվազագույն քանակով լուծումը։

Խաղ 15-ի ընդհանրացում կարող է լինել _Խաղ N×M_֊ը, որտեղ `N×M-1` հատ խաղաքարերը դասավորված `N` տողերով և `M` սյուներով խաղադաշտի վրա։ Խաղի կանոնները նույնն են։

Խաղը սկսվում է թվերի պատահական դասավորությամբ, որտեղ զրո թիվը գտնվում է ներքևի աջ անկյունում։ Այդ դասավորությունը պետք է _լուծելի_ լինի։ Այն է, պետք է հնարավոր լինի վերջավոր քանակի տեղափոխություններով (տրանսպոզիցիաներով) թվերը դասավորել աճման կարգով։ Այդ հնարավորությունը ապահովում է թվերի վեկտորի _ինվերսիաների_ զույգ լինելը։ (_լրացնել մաթեմատիկական հիմնավորմամբ_)


## Իրականացման պահանջներ



## Խաղի տրամաբանության մոդելը

Խաղի տրամաբանությունը մոդելավորող `GameNxM` դասը նախատեսված է նոր խաղ ստեղծելու, խաղի մեկ քայլ կատարելու և խաղի ավարտը որոշելու համար։

Այս դասի `rows` և `columns` անդամները համապատասխանաբար ցույց են տալիս խաղի մատրիցի տողերն ու սյուները, իսկ `matrix`֊ը խաղի մատրիցն է։

````c++
class GameNxM {
public:
    // Կոնստրուկտոր
    GameNxM( unsigned int rw, unsigned int cl );

    // Խաղի նախապատրաստում
    void reset();

    // Մեկ քայլի կատարում
    void step( unsigned int rw, unsigned int cl );

    // Խաղի ավարտված լինելը
    bool gameOver() const;

    // Մատրիցի տրված բջջի արժեքը
    int valueAt( unsigned int ro, unsigned int cl ) const;

private:
    unsigned int rows = 0; // տողերի քանակը
    unsigned int columns = 0; // սյուների քանակը
    QVector<QVector<int>> matrix; // թվերի մատրիցը
};
````

### Կոնստրուկտորը

Կոնստրուկտորը ստանում է թվերի մատրիցի տողերի և սյուների քանակը, և դրանք վերագրում է համապատասխանաբար դասի `rows` և `columns` անդամներին, ապա կանչում է նոր խաղ ստեղծող `reset` մեթոդը։

````c++
GameNxM::GameNxM( unsigned int rw, unsigned int cl )
    : rows{rw}, columns{cl}
{
    reset();
}
````

### Նոր խաղի ստեղծումը

`reset` մեթոդը `rows` տողերի և `columns` սյուների փոխարեն ստեղծում է `rows+2` տողերով և `columns+2` սյուներով մատրից։ Այս լրացուցիչ տողերն անհարժեշտ են, որպեսզի խաղի մեկ քայլը կատերելիս մատրիցի բոլոր բջիջների համար կատարվեն նույնանման ստուգումներ։

````c++
matrix.clear();
    for( uint r = 0; r < rows + 2; ++r )
        matrix.push_back( QVector<int>(columns + 2, -1) );
````

Օրինակ, `4×4` չափի խաղի համար դեևս չարժեքավարված մատրիցը կունենա հետևյալ տեսքը, որտեղ լրացուցիչ վանդակերնը պարունակում են `-1` արժեքը։

```
+----+----+----+----+----+----+
| -1 | -1 | -1 | -1 | -1 | -1 |
+----+----+----+----+----+----+
| -1 |    |    |    |    | -1 |
+----+----+----+----+----+----+
| -1 |    |    |    |    | -1 |
+----+----+----+----+----+----+
| -1 |    |    |    |    | -1 |
+----+----+----+----+----+----+
| -1 |    |    |    |    | -1 |
+----+----+----+----+----+----+
| -1 | -1 | -1 | -1 | -1 | -1 | 
+----+----+----+----+----+----+
```

Այնուհետև գեներացվում են `[1;N×M-1]` միջակայքի հաջորդական թվերը․

````c++
int count = rows * columns - 1;
QVector<int> rnums(count);
std::iota(rnums.begin(), rnums.end(), 1);
````

C++ լեզվի շաբլոնների ստանդարտ գրադարանի `iota` ալգորիթմը `rnums` կոնտեյները լրացնում է `1`֊ից սկսող հաջորդական թվերով։

Ստանադարդ գրադարանի մեկ այլ ալգորիթմ՝ `shuffle`, պատահական եղանակով խառնում է տրված կոնտեյների տարրերը՝ օգտագործելով պատահական թվերի մի որևէ գեներատոր։ Տվյալ պքում այդ գեներատորը `default_random_engine` է․

````c++
auto re = std::default_random_engine{};
std::shuffle(rnums.begin(), rnums.end(), re);
````

Խմբերի տեսությունից հայտնի է, որ Խաղ 15֊ը _լուծելի_ է միայն այն դեպքում, երբ խառնելուց հետո առաջացած ինվերսիաների քանակը զույգ է։ Դա ապահովելու համար նախ հաշվվում է ինվերսիաների քանակը․

````c++
int inv = 0;
for( int i = 0; i < count - 1; ++i )
    for( int j = i + 1; j < count; ++ j )
        if( rnums[i] > rnums[j] ) ++inv;
````

Հետո, եթե այդ թիվը կենտ է, ապա տեղերով փոխվում են առաջին երկու տարրերը՝ կարարվում է ևս մի տրանսպոզիցիա․

````c++
if( inv % 2 == 1 ) qSwap(rnums[0], rnums[1]);
````

Մնում է այս թվերով արժեքավորել խաղի մատրիցը, բայց մինչ այդ պետք է ավելացնել նառ վերջին `0`֊ն։

````c++
rnums.push_back(0);

int nx = 0;
for( unsigned int r = 1; r <= rows; ++r )
    for( unsigned int c = 1; c <= columns; ++c )
        matrix[r][c] = rnums[nx++];
````


### Մեկ քայլի կատարումը

Խաղացողը կարող է տեղաշարժել միայն այն խաղաքարերը, որոնց հարևանությամբ գտնվում է դատատրկ վանդակը։ Խաղի մոդելի տեսակետից դատարկ է համարվում մատրիցի `0` թիվը պարունակող բջիջը։ 

````c++
void GameNxM::step( unsigned int rw , unsigned int cl )
{
    if( matrix[rw-1][cl] == 0 )
        qSwap(matrix[rw][cl], matrix[rw-1][cl]);
    else if( matrix[rw+1][cl] == 0 )
        qSwap(matrix[rw][cl], matrix[rw+1][cl]);
    else if( matrix[rw][cl-1] == 0 )
        qSwap(matrix[rw][cl], matrix[rw][cl-1]);
    else if( matrix[rw][cl+1] == 0 )
        qSwap(matrix[rw][cl], matrix[rw][cl+1]);
}
````

